C51 COMPILER V9.60.7.0   KEYSCAN                                                           05/23/2025 14:21:34 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE KEYSCAN
OBJECT MODULE PLACED IN .\Objects\keyscan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE keyscan.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\keyscan.lst) TABS(2) OBJECT(.\Objects\keyscan.obj)

line level    source

   1          #include <REGX52.H>
   2          #include <delay.h>
   3          #include <string.h>
   4          #include <keyscan.h>
   5          #include <math.h>
   6          #include <stdlib.h>
   7          #include <LCD1602.h>
   8          //double myatof(char *read_in)
   9          //{
  10          //    int i,len,how_lone;
  11          //    double replace_float=0;
  12          //    len=strlen(read_in);
  13          //    for(i=0;i<len;i++)
  14          //    {
  15          //        if(read_in[i]=='.')
  16          //        {
  17          //            how_lone=i;
  18          //            continue;
  19          //        }
  20          //        replace_float=replace_float*10+read_in[i]-'0';
  21          //        
  22          //    }
  23          //    return replace_float;
  24          //}
  25          
  26          int myisdigit (char a)
  27          {
  28   1          if (a>='0'&&a<='9'||a=='.')
  29   1          return 1;
  30   1          else return 0;
  31   1      }
  32          
  33          
  34          
  35          int isfuhao (char a)
  36          {
  37   1        if (a=='+'||a=='-'||a=='*'||a=='/'||a==' ')
  38   1            return 1;
  39   1            else return 0;  
  40   1      }
  41          
  42          void float2char(float slope,char*buffer,int n)  //浮点型数，存储的字符数组，字符数组的长度
  43          {
  44   1          char temp,i,j;
  45   1          if(slope>=0)//判断是否大于0
  46   1              buffer[0] = '+';
  47   1          else
  48   1          {
  49   2              buffer[0] = '-';
  50   2              slope = -slope;
  51   2          }
  52   1          temp = (int)slope;//取整数部分
  53   1          for(i=0;temp!=0;i++)//计算整数部分的位数
  54   1              temp /=10;
C51 COMPILER V9.60.7.0   KEYSCAN                                                           05/23/2025 14:21:34 PAGE 2   

  55   1          temp =(int)slope;
  56   1          for(j=i;j>0;j--)//将整数部分转换成字符串型
  57   1          {
  58   2              buffer[j] = temp%10+'0';
  59   2              temp /=10;
  60   2          }
  61   1          buffer[i+1] = '.';
  62   1          slope -=(int)slope;
  63   1          for(i=i+2;i<n-1;i++)//将小数部分转换成字符串型
  64   1          {
  65   2              slope*=10;
  66   2              buffer[i]=(int)slope+'0';
  67   2              slope-=(int)slope;
  68   2          }
  69   1          buffer[n-1] = '\0';
  70   1      }
  71          int my_strlen(const char* str)
  72          {
  73   1        char count = 0;//count用来记录字符串的字符个数
  74   1         while(*str != '\0')//即从首元素地址开始一个个往后找'\0',并记录找到的字符个数
  75   1        {
  76   2          count++;
  77   2          str++;
  78   2        }
  79   1        return count;
  80   1      }
  81          
  82          float jisuan(char *temp)  
  83          {
  84   1        double e=2.71828182;
  85   1        double num=0;
  86   1        char temp1[16]={""};
  87   1        char temp2[16]={""};
  88   1        char temp3[16]={""};
  89   1        float zhi1,zhi2;
  90   1        char i,m,biaozhi,w1,w2,top;
  91   1        char len=0;
  92   1        char fuhao='+';
  93   1        char lastfuhao='+';
  94   1        double stk[10];
  95   1        double result=0;
  96   1        top=0;
  97   1        len=my_strlen(temp);
  98   1        result=0;
  99   1        for(i=0;i<10;i++)
 100   1        {
 101   2          stk[i]=0;
 102   2        }
 103   1        for(i=0;i<len;i++)
 104   1        {   
 105   2        if (myisdigit(temp[i])) //转成整数程序
 106   2          {
 107   3            if(temp[i]>='0'&&temp[i]<='9')
 108   3            num = num * 10 + (int)(temp[i] - '0');    
 109   3            if(temp[i]=='.')
 110   3            {m=i;biaozhi=1;continue;}         
 111   3          }
 112   2        if(!myisdigit(temp[i])||i==len-1||temp[i]=='\0') //扫描停止判断
 113   2        {   
 114   3          
 115   3          if(temp[i]=='(')   //括号特殊处理判断
 116   3        {
C51 COMPILER V9.60.7.0   KEYSCAN                                                           05/23/2025 14:21:34 PAGE 3   

 117   4          w1=i;
 118   4          for(i;i<len;i++)
 119   4          {
 120   5            if(temp[i]==')')      
 121   5            {w2=i;break;}
 122   5          }
 123   4          strncpy(temp1, temp+w1+1, w2-w1-1);
 124   4          num=jisuan1(temp1);
 125   4        } 
 126   3              if(biaozhi)   //转化小数
 127   3          {
 128   4          if(isfuhao(temp[i]))
 129   4          num=num*pow(0.1,i-m-1);
 130   4          else
 131   4          num=num*pow(0.1,i-m);
 132   4          biaozhi=0;
 133   4          } 
 134   3          switch(fuhao)
 135   3          {
 136   4          case '+':stk[top]=num;top++;break;
 137   4          case '-':stk[top]=-num;top++;break;
 138   4          case '*':stk[top-1]*=num;break;
 139   4          case '/':stk[top-1]/=num;break;            
 140   4          }
 141   3          num=0;
 142   3          lastfuhao=fuhao;
 143   3          fuhao=temp[i];
 144   3        }   
 145   2        }
 146   1        for(i=0;i<top;i++)
 147   1        {
 148   2          result+=stk[i];
 149   2        } 
 150   1        LCD_ShowNum(2,8,result,5);
 151   1          return result;
 152   1      }
*** WARNING C280 IN LINE 89 OF keyscan.c: 'zhi1': unreferenced local variable
*** WARNING C280 IN LINE 89 OF keyscan.c: 'zhi2': unreferenced local variable
 153          
 154          float jisuan1(char *temp)
 155          {
 156   1        double num=0;
 157   1        char i,len,m,biaozhi;
 158   1        char fuhao='+';
 159   1        char lastfuhao='-';
 160   1        char top;
 161   1        double stk1[5];
 162   1        double result=0;
 163   1        top=0;
 164   1        len=strlen(temp);
 165   1        for(i=0;i<len;i++)
 166   1        {
 167   2        if (myisdigit(temp[i]))
 168   2          {
 169   3            if(temp[i]>='0'&&temp[i]<='9')
 170   3            num = num * 10 + (int)(temp[i] - '0');    
 171   3            if(temp[i]=='.')
 172   3            {m=i;biaozhi=1;continue;}         
 173   3          }
 174   2        if(!myisdigit(temp[i])||i==len-1||temp[i]=='\0')
 175   2        {   
 176   3          if(biaozhi)
C51 COMPILER V9.60.7.0   KEYSCAN                                                           05/23/2025 14:21:34 PAGE 4   

 177   3          {
 178   4          if(isfuhao(temp[i]))
 179   4          num=num*pow(0.1,i-m-1);
 180   4          else
 181   4          num=num*pow(0.1,i-m);
 182   4          biaozhi=0;
 183   4          } 
 184   3          switch(fuhao)
 185   3          {
 186   4          case '+':stk1[top]=num;top++;break;
 187   4          case '-':stk1[top]=-num;top++;break;
 188   4          case '*':stk1[top-1]*=num;break;
 189   4          case '/':stk1[top-1]/=num;break;
 190   4          
 191   4          }
 192   3          num=0;
 193   3          lastfuhao=fuhao;
 194   3          fuhao=temp[i];
 195   3        }   
 196   2        }
 197   1        for(i=0;i<top;i++)
 198   1        {
 199   2          result+=stk1[i];
 200   2        } 
 201   1          return result;
 202   1      }
 203          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2855    ----
   CONSTANT SIZE    =     48    ----
   XDATA SIZE       =   ----     168
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
